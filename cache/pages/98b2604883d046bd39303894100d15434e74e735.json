{
  "url": "https://www.freecodecamp.org/portuguese/news/node-js-o-que-e-quando-como-e-por-que-usar/",
  "title": "Node.js: o que √©, quando, como e por que usar",
  "text": "Artigo original: Node.js: what it is, when and how to use it, and why you should Escrito por: Pablo Regen Voc√™, provavelmente, j√° leu essas frases antes‚Ä¶ O Node.js √© um ambiente de tempo de execu√ß√£o de JavaScript criado usando a engine de JavaScript do Chrome, a V8 O Node.js usa um modelo ass√≠ncrono e n√£o bloqueador da E/S, orientado a eventos O Node.js opera em um loop de eventos em thread √∫nica Se j√°, voc√™ pode ter se perguntado o significado de tudo isso. Ao final deste artigo, espero que voc√™ tenha uma compreens√£o melhor dessas frases e saiba o que o Node √©, como ele funciona e por que e quando √© uma boa ideia us√°-lo. Vamos come√ßar examinando a terminologia. E/S (entrada e sa√≠da ‚Äì em ingl√™s I/O, ou input/output) E/S √© a abrevia√ß√£o para (dispositivos de) entrada/sa√≠da. E/S (ou I/O) tem a ver primordialmente com a intera√ß√£o do programa com o disco e com a rede do sistema. Exemplos de opera√ß√µes de E/S incluem a leitura/grava√ß√£o de dados de/para uma unidade de disco, a realiza√ß√£o de solicita√ß√µes de HTTP e a comunica√ß√£o com um banco de dados. S√£o dispositivos muito lentos se comparados com o acesso √† mem√≥ria (RAM) ou com a realiza√ß√£o de tarefas pela CPU. S√≠ncrono x Ass√≠ncrono Execu√ß√£o s√≠ncrona (ou \"sync\") geralmente se refere ao c√≥digo sendo executado em sequ√™ncia. Na programa√ß√£o s√≠ncrona, o programa √© executado linha a linha, uma linha de cada vez. Sempre que uma fun√ß√£o √© chamada, a execu√ß√£o do programa aguarda at√© que aquela fun√ß√£o retorne um resultado antes de continuar na pr√≥xima linha do c√≥digo. Execu√ß√£o ass√≠ncrona (ou \"async\") √© a execu√ß√£o que n√£o √© feita na mesma sequ√™ncia em que aparece no c√≥digo. Na programa√ß√£o ass√≠ncrona, o programa n√£o aguarda at√© que a tarefa seja conclu√≠da, podendo seguir para a pr√≥xima tarefa. No exemplo a seguir, a opera√ß√£o s√≠ncrona faz com que os alertas sejam disparados em sequ√™ncia. Na opera√ß√£o ass√≠ncrona, embora alert(2) pare√ßa ser o segundo a ser executado, n√£o √© isso que acontece. // Opera√ß√£o s√≠ncrona: 1,2,3 alert(1); alert(2); alert(3); // Opera√ß√£o ass√≠ncrona: 1,3,2 alert(1); setTimeout(() => alert(2), 0); alert(3); Uma opera√ß√£o ass√≠ncrona √© frequentemente relacionada a E/S, embora setTimeout seja um exemplo de algo que n√£o tenha a ver com E/S, mas ainda seja ass√≠ncrono. De um modo geral, qualquer coisa relacionada √† computa√ß√£o √© sincronizada e qualquer coisa relacionada √† entrada/sa√≠da/tempo √© ass√≠ncrona. A raz√£o para as opera√ß√µes de E/S serem feitas de maneira ass√≠ncrona √© que elas s√£o muito lentas e bloqueariam a execu√ß√£o adicional do c√≥digo do contr√°rio. Bloqueador x n√£o bloqueador O modelo bloqueador se refere a opera√ß√µes que bloqueiam/impedem o resto da execu√ß√£o at√© que aquela opera√ß√£o esteja conclu√≠da. N√£o bloqueador, por sua vez, se refere ao c√≥digo que n√£o impede o resto da execu√ß√£o. Conforme vemos na documenta√ß√£o do Node.js, opera√ß√µes bloqueadoras ocorrem quando a execu√ß√£o de JavaScript adicional no processo do Node.js deve aguardar at√© que uma opera√ß√£o n√£o relacionada ao JavaScript seja conclu√≠da. M√©todos bloqueadores executam de modo s√≠ncrono, enquanto m√©todos n√£o bloqueadores executam de modo ass√≠ncrono. // Bloqueador const fs = require('fs'); const dados = fs.readFileSync('/arquivo.md'); // h√° um bloqueio aqui at√© que o arquivo seja lido console.log(dados); maisTarefas(); // ser√° executado ap√≥s o console.log // N√£o bloqueador const fs = require('fs'); fs.readFile('/arquivo.md', (err, dados) => { if (err) throw err; console.log(dados); }); maisTarefas(); // ser√° executado antes do console.log No primeiro exemplo, console.log ser√° chamado antes de maisTarefas() . No segundo exemplo, fs.readFile() √© n√£o bloqueador, o que faz com que a execu√ß√£o do JavaScript possa continuar e chamar maisTarefas() primeiro. No Node, n√£o bloqueador tem primordialmente a ver com opera√ß√µes de E/S e com JavaScript de baixo desempenho em fun√ß√£o de demandar demais da CPU, enquanto aguardar por uma opera√ß√£o que n√£o seja do JavaScript, como as opera√ß√µes de E/S, n√£o √© tipicamente considerado bloqueador. Todos os m√©todos de E/S na biblioteca padr√£o do Node.js fornecem vers√µes ass√≠ncronas ‚Äì e, portanto, n√£o bloqueadoras ‚Äì e que aceitam fun√ß√µes de callback. Alguns m√©todos tamb√©m t√™m equivalentes bloqueadores, cujos nomes terminam em \"Sync\" (veja os exemplos de readFile e readFileSync acima). Opera√ß√µes de E/S n√£o bloqueadores permitem que um √∫nico processo sirva diversas solicita√ß√µes ao mesmo tempo. Em vez de o processo ser bloqueado e ficar esperando que opera√ß√µes de E/S sejam conclu√≠das, as opera√ß√µes de E/S s√£o delegadas ao sistema. Assim, o processo pode executar a parte seguinte do c√≥digo. Opera√ß√µes de E/S n√£o bloqueadoras fornecem uma fun√ß√£o de callback, que √© chamada quando a opera√ß√£o √© conclu√≠da. Callbacks Callbacks s√£o fun√ß√µes passadas como argumento de uma outra fun√ß√£o, e que, ent√£o, podem ser invocadas (chamadas novamente, ou, em ingl√™s, called back) dentro da fun√ß√£o externa para concluir algum tipo de a√ß√£o na hora em que for conveniente. A chamada pode ser imediata (callback s√≠ncrona) ou pode acontecer mais tarde (callback ass√≠ncrona). // Callback s√≠ncrona function saudacao(callback) { callback(); } saudacao(() => { console.log('Ol√°'); }); maisTarefas(); // ser√° executado ap√≥s o console.log // Callback ass√≠ncrona const fs = require('fs'); fs.readFile('/arquivo.md', function callback(err, dados) { // fs.readFile √© um m√©todo ass√≠ncrono fornecido pelo Node if (err) throw err; console.log(dados); }); maisTarefas(); // ser√° executado antes do console.log No primeiro exemplo, a fun√ß√£o de callback √© chamada imediatamente dentro da fun√ß√£o externa saudacao e faz o registro no console antes que maisTarefas() seja executada. No segundo exemplo, fs.readFile (um m√©todo ass√≠ncrono fornecido pelo Node) l√™ o arquivo e, quando termina, chama a fun√ß√£o de callback com um erro ou o conte√∫do do arquivo. Enquanto isso, o programa pode continuar a execu√ß√£o do c√≥digo. Uma fun√ß√£o de callback ass√≠ncrona pode ser chamada quando um evento acontece ou quando uma tarefa √© conclu√≠da. Ela evita o bloqueio, permitindo que outro c√≥digo seja executado enquanto isso. Em vez de o c√≥digo ser lido de cima para baixo de modo procedural, os programas ass√≠ncronos podem executar fun√ß√µes diferentes em momentos diferentes com base na ordem e velocidade em que fun√ß√µes anteriores, como solicita√ß√µes de http ou leituras do sistema de arquivos, acontecem. Eles s√£o usados quando voc√™ n√£o sabe quando alguma opera√ß√£o ass√≠ncrona ser√° conclu√≠da. √â preciso, no entanto, evitar o chamado \"inferno das callbacks\", situa√ß√£o na qual as callbacks s√£o aninhadas dentro de outras callbacks por v√°rios n√≠veis, tornando o c√≥digo de dif√≠cil compreens√£o, al√©m de dif√≠cil de manter e depurar. Eventos e programa√ß√£o orientada a eventos Eventos s√£o a√ß√µes geradas pelo usu√°rio ou pelo sistema, como um clique, um download de arquivo conclu√≠do ou um erro de hardware ou software. A programa√ß√£o orientada a eventos √© um paradigma de programa√ß√£o no qual o fluxo do programa √© determinado por eventos. Um programa orientado a eventos executa a√ß√µes em resposta a eventos. Quando ocorre um evento, ele dispara uma fun√ß√£o de callback. Agora, vamos tentar entender o Node e ver como tudo isso se relaciona com ele. Node.js: o que √©, por que foi criado e como funciona? Colocado de maneira simples, o Node.js √© uma plataforma que executa programas em JavaScript do lado do servidor que pode se comunicar com fontes de E/S, como redes e arquivos de sistemas. Quando Ryan Dahl criou o Node em 2009, ele disse que a E/S vinha sendo manipulada incorretamente, bloqueando todo o processo devido √† programa√ß√£o s√≠ncrona. T√©cnicas de servir conte√∫do para a web tradicionais usavam o modelo de threads, ou seja, usavam uma thread para cada solicita√ß√£o. Como, em uma opera√ß√£o de E/S, a solicita√ß√£o passa a maior parte do tempo aguardando at√© ser conclu√≠da, cen√°rios com uso intenso de E/S incorporam uma grande quantidade de recursos n√£o utilizados (como a mem√≥ria) associados a essas threads. Portanto, o modelo de \"uma thread por solicita√ß√£o\" para um servidor √© um modelo que n√£o dimensiona muito bem. Dahl argumentou que o software deveria ser capaz de realizar v√°rias tarefas e prop√¥s eliminar o tempo gasto aguardando que os resultados de E/S retornassem. Em vez do modelo de threads, ele disse que a maneira certa de lidar com v√°rias conex√µes simult√¢neas era ter uma thread √∫nica, um loop de eventos e E/S sem bloqueio. Por exemplo, quando voc√™ faz uma consulta a um banco de dados, em vez de aguardar a resposta, voc√™ d√° a ele uma fun√ß√£o de callback para que sua execu√ß√£o possa rodar essa instru√ß√£o e continuar fazendo outras coisas. Quando os resultados retornam, voc√™ pode executar a callback. O loop de eventos √© o que permite que o Node.js execute opera√ß√µes de E/S sem bloqueio, apesar do fato de que o JavaScript √© de thread √∫nica. O loop, que √© executado na mesma thread que o c√≥digo em JavaScript, pega uma tarefa do c√≥digo e a executa. Se a tarefa for ass√≠ncrona ou uma opera√ß√£o de E/S, o loop a delegar√° para o kernel do sistema, como no caso de novas conex√µes com o servidor, ou para um pool de threads, como opera√ß√µes relacionadas ao sistema de arquivos. O loop, ent√£o, pega a pr√≥xima tarefa e a executa. Como a maioria dos kernels modernos t√™m v√°rias threads, eles podem lidar com v√°rias opera√ß√µes em execu√ß√£o em segundo plano. Quando uma dessas opera√ß√µes √© conclu√≠da (este √© um evento), o kernel informa a Node.js para que a callback apropriada (aquela que dependia da conclus√£o da opera√ß√£o) possa ser adicionada √† fila para, por fim, ser executada. O n√≥ controla as opera√ß√µes ass√≠ncronas inacabadas, enquanto o loop de eventos continua em loop para verificar se elas est√£o conclu√≠das at√© que todas elas estejam. Para acomodar o loop de eventos de thread √∫nica, o Node.js usa a biblioteca libuv, que, por sua vez, usa um pool de threads de tamanho fixo que lida com a execu√ß√£o de algumas das opera√ß√µes de E/S ass√≠ncronas n√£o bloqueadoras em paralelo. As fun√ß√µes de chamada da thread principal lan√ßam tarefas na fila de tarefas compartilhadas, que as threads no pool de threads resgatam e executam. Fun√ß√µes do sistema inerentemente sem bloqueio, como a rede, s√£o convertidas em soquetes sem bloqueio do lado do kernel, enquanto fun√ß√µes do sistema inerentemente bloqueadas, como E/S de arquivos, s√£o executadas de maneira bloqueada em suas pr√≥prias threads. Quando uma thread no pool de threads conclui uma tarefa, ela informa a thread principal sobre isso, que, por sua vez, ativa e executa a callback registrada. A imagem acima √© retirada da apresenta√ß√£o de Philip Roberts na JSConf EU: What the heck is the event loop anyway? (\"O que diabos √© esse o loop de eventos?\", em portugu√™s). Recomendo assistir o v√≠deo inteiro (em ingl√™s) para se ter uma ideia geral de como funciona o loop de eventos. O diagrama explica como o loop de eventos funciona com o navegador, mas sua apar√™ncia √© basicamente id√™ntica √† do Node. Em vez de APIs da Web, ter√≠amos APIs do Node. De acordo com a apresenta√ß√£o, a pilha de chamadas (tamb√©m conhecida como pilha de execu√ß√£o, \"call stack\" ou, simplesmente, \"a stack\") √© uma estrutura de dados que registra onde no programa estamos. Se entrarmos em uma fun√ß√£o, colocamos algo na pilha. Se retornarmos de uma fun√ß√£o, n√≥s a tiramos do topo da pilha. √â assim que o c√≥digo no diagrama √© processado quando o executamos: - Colocamos main() na pilha (o pr√≥prio arquivo) - Colocamos console.log('Hi'); na pilha, que √© executado imediatamente, registrando \"Hi\" (\"Ol√°\") no console e sendo removido da pilha - Colocamos setTimeout(cb, 5000) na pila.setTimeout √© uma API fornecida pelo navegador (no back-end, seria uma API do Node). QuandosetTimeout √© chamada com a fun√ß√£o de callback e com os argumentos de atraso, o navegador aciona um temporizador com o tempo de atraso (no caso, 5 mil milissegundos) - A chamada de setTimeout √© conclu√≠da e ela √© removida da pilha - Colocamos console.log(‚ÄòJSConfEU‚Äô); na pilha, que executa imediatamente, registrando \"JSConfEU\" no console e √© removida da pilha main() √© removida da pilha- Ap√≥s 5 mil milissegundos, o temporizador da API conclui e a fun√ß√£o de callback √© movida para a fila de tarefas - O loop de eventos verifica se a pilha est√° vazia, j√° que o JavaScript, por ser de thread √∫nica, s√≥ consegue fazer uma coisa por vez ( setTimeout n√£o √© garantido, apenas um tempo m√≠nimo para a execu√ß√£o). Se a pilha estiver vazia, ele pega a primeira coisa que estiver na fila e a envia para a pilha. Assim, o loop coloca a callback na pilha - A callback √© executada, registra \"there\" (no final, temos a express√£o \"Hi there\", algo como \"Ol√°, pessoal!\", registrado) no console e √© removida da pilha. Isso encerra o processo Se quiser se aprofundar ainda mais nos detalhes de como o Node.js, a libuv, o loop de eventos e o pool de threads funcionam, sugiro conferir os recursos na se√ß√£o se refer√™ncias do final ‚Äì em especial esta, esta e esta refer√™ncias, juntamente com a documenta√ß√£o do Node (texto e v√≠deos em ingl√™s). Node.js: por que e onde us√°-lo? Como quase nenhuma fun√ß√£o no Node executa diretamente a E/S, o processo nunca bloqueia (as opera√ß√µes de E/S s√£o descarregadas e executadas de maneira ass√≠ncrona no sistema), tornando-se uma boa op√ß√£o para desenvolver sistemas altamente escal√°veis. Devido ao seu loop de eventos orientado a eventos, thread √∫nica e modelo de E/S ass√≠ncrono sem bloqueio, o Node.js tem melhor desempenho em aplica√ß√µes de uso intenso de E/S que exigem velocidade e escalabilidade com muitas conex√µes simult√¢neas, como streaming de v√≠deo e √°udio, aplica√ß√µes em tempo real, bate-papos ao vivo, aplica√ß√µes de jogos, ferramentas de colabora√ß√£o ou software de bolsa de valores. O Node.js pode n√£o ser a escolha certa para opera√ß√µes que exigem muito da CPU. Em vez disso, o modelo de thread tradicional pode ter um desempenho melhor. npm O npm √© o gerenciador de pacotes padr√£o do Node.js e √© instalado no sistema quando o Node.js √© instalado. Ele pode gerenciar pacotes que s√£o depend√™ncias locais de um projeto espec√≠fico, bem como ferramentas do JavaScript instaladas de modo global. O site www.npmjs.com hospeda milhares de bibliotecas gratuitas para baixar e usar em seu programa para tornar o desenvolvimento mais r√°pido e eficiente. No entanto, como qualquer pessoa pode criar bibliotecas e n√£o h√° processo de verifica√ß√£o para o envio, voc√™ deve ter cuidado com as de baixa qualidade, inseguras ou maliciosas. O npm depende de relat√≥rios de usu√°rios para remover pacotes se eles violarem as pol√≠ticas e, para ajudar voc√™ a decidir, inclui estat√≠sticas como n√∫mero de downloads e n√∫mero de pacotes dependentes. Como executar c√≥digo no Node.js Comece instalando o Node no seu computador, se voc√™ ainda n√£o o tiver. A maneira mais f√°cil √© visitar nodejs.org e clicar no bot√£o para fazer o download. A menos que voc√™ queira ou precise ter acesso aos recursos mais recentes, baixe a vers√£o LTS (Long Term Support ‚Äì em portugu√™s, suporte de longa dura√ß√£o) para seu sistema operacional. Voc√™ executa uma aplica√ß√£o do Node a partir do terminal do seu computador. Por exemplo, fa√ßa um arquivo chamado \"app.js\" e adicione console.log('Ol√°'); a ele. No seu terminal, mude o diret√≥rio para a pasta onde se encontra o arquivo e execute o comando node app.js . Voc√™ ver√° \"Ol√°\" no console. üôÇ Refer√™ncias Aqui temos alguns recursos interessantes que eu revisei durante a composi√ß√£o deste artigo. Apresenta√ß√µes do Node.js feitas pelo criador (em ingl√™s): - Apresenta√ß√£o original do Node.js, feita por Ryan Dahl na JSConf 2009 - 10 coisas das quais me arrependo com o Node.js, feita por Ryan Dahl na JSConf EU 2018 Apresenta√ß√µes sobre o Node, o loop de eventos e a biblioteca libuv (em ingl√™s): - What the heck is the event loop anyway?, feita por Philip Roberts na JSConf EU - Node.js Explained, por Jeff Kunkle - In The Loop, feita por Jake Archibald na JSConf Asia 2018 - Everything You Need to Know About Node.js Event Loop, por Bert Belder - A deep dive into libuv, por Saul Ibarra Coretge na NodeConf EU 2016 Documenta√ß√£o do Node (em ingl√™s): - About Node.js - The Node.js Event Loop, Timers, and process.nextTick() - Overview of Blocking vs Non-Blocking Recursos adicionais (em ingl√™s, exceto os recursos da Wikip√©dia): - Art of Node, por Max Ogden - Callback hell, por Max Ogden - What is non-blocking or asynchronous I/O in Node.js?, no Stack Overflow - Programa√ß√£o orientada a eventos na Wikip√©dia - Node.js na Wikip√©dia - Thread na Wikip√©dia - libuv Obrigado pela leitura."
}